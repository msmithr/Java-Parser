<qualified_identifier> = <identifier> {"." <identifier>};

<program> = "package" <qualified_identifier> ";" {<import>} <class>;
<import> = "import" ["static"] <identifier> {"." <identifier>} [".*"] ";" ;

<class> = {<modifier>} <class declaration>;
<class_declaration> = "class" <identifier> [<extends>] [<implements>] <class_body>;

<modifier> = "public"
    | "protected"
    | "private"
    | "static"
    | "abstract"
    | "final"
    | "native"
    | "synchronized"
    | "transient"
    | "volatile"
    | "strictfp";

<primitive_type> = "boolean"
    | "byte"
    | "char"
    | "short"
    | "int"
    | "long"
    | "float"
    | "double";

<extends> = "extends" <identifier>;
<implements> = "implements" <identifier> {',' <identifier>};

<class body> = '{' {<class body statement>} '}';

<class body statement> = ';' | {<modifier>} <class_body_declaration> | ["static"] <block>;

<class_body_declaration> = <class_declaration>
    | "void" <identifier> <method_declaration>
    | <identifier> <method_declaration>
    | <type> <identifier> <method_declaration>
    | <type> <identifier> <field_declaration> ";";

<field_declaration> = {"[]"} ["=" <variable_init>] <variable_declarators_half>;

<variable_declarators> = <variable_declarator> <variable_declarators_half>;
<variable_declarator> = <identifier> {'[]'} ["=" <variable_init>];
<variable_declarators_half> = {"," <variable_declarator>};

<method_declaration> = <parameters> [<throws>] (<block> | ";");

<parameters> = "(" [<parameter> {, <parameter>}] ")";
<parameter> = {<modifier>} <type> <identifier>{"[]"};

<block> = '{' {<block_statement> }"}";

<block_statement> = {<modifier>} (
	<class_declaration>
	| <local_variable_declaration>
	| <identifier> ":" <statement>
	| <identifier> {"[]"} <variable_declarators>
);
(*Problem here in block: <identifier> could also be an expression*)

<local_variable_declaration> = <type> <variable_declarators>;

<type> = (<primitive_type> | <identifier>) {"[]"};

<variable_init> = <expression> | <array_init>;
<array_init> = "{" [<variable_init> {"," <variable_init>}] "}";

<statement> = "if" <paren_expression> ["else" <statement>]
    | "while" <paren_expression> <statement>
    | "do" <statement> "while" <paren_expression> ";"
    | "for" "(" [{<modifier>} <type> <identifier> {"[]"}] ["=" <variable_init>] <for_arguments> ")" <statement>
    | "assert" <expression> [:<expression>] ";"
    | "switch" <paren_expression> "{" <cases> "}"
    | "return" [<expression>] ";"
    | "break" [<identifier>] ";"
    | "continue" [<identifier>] ";"
    | "throw" <expression> ";"
    | "try" <block> [<catches>] ["finally" <block>]
    | "synchronized" <paren_expression> <block>
    | <block>
    | ";"
    | <identifier> ":" <statement>
    | <expression>;

<cases> = { ("case" (<identifier> | <expression>) | "default") ":" {<block_statement>} };

<catches> = <catch> {<catch>};
<catch> = "catch" "(" {<modifier>} <qualified_identifier> <identifier> ")" <block>;

<for_arguments> = ";" [<expression>] ";" <expression> {"," <expression>}
	| ":" <expression>;

<expression> = <expression1> [<assignment_operator> <expression1>];
<expression1> = <expression2> ["?" <expression> ":" <expression1>];
<expression2> = <expression3> [("instanceOf" <type> | {<infix_operator> <expression3>})];
<expression3> = <prefix_operator> <expression3>
    | "(" (<expression> | <type>) ")" <expression3>
    | <expression_unit> {<selector>} {<postfix_operator>};

<expressionHalf> = <assignment_operator> <expression1>;


<expression_unit> = <literal>
	| <paren_expression>
	| "this" [<arguments>]
	| "super" (<arguments> | "." <identifier> [<arguments>]);
	| (*New*)
	| (*???*)
	| <identifier> {"." <identifier>} [(*Identifier Suffix?*)]
	| <primitive_type> {"[]"} "." "class"
	| "void" "." "class";

<paren_expression> = "(" <expression> ")";

<arguments> = "(" [<expression> {"," <expression>}] ")";

<literal> = <int_lit>
	| <int_lit> "." <int_lit>
	| '<identifier>'
	| "<identifier>"
	| ("true" | "false");
	| "null";

<infix_operator> = INFIX_OPERATOR
	| OPERATOR_PLUS
	| OPERATOR_MINUS;

<prefix_operator> = PREFIX_OPERATOR
	| OPERATOR_PLUS
	| OPERATOR_MINUS
	| OPERATOR_INCREMENT
	| OPERATOR_DECREMENT;

<postfix_operator> = OPERATOR_INCREMENT
	| OPERATOR_DECREMENT;
